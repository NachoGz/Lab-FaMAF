# Laboratorio 2: Desarrollo de una aplicaciÃ³n servidor

[link al video ðŸ‘‰ðŸŽ¥](https://drive.google.com/file/d/1olQL5lRAabZsVAI606YpG2zN0G4ZOjai/view?usp=sharing)

## IntroducciÃ³n
Este trabajo tiene como objetivo implementar un programa que realice una comunicaciÃ³n cliente/servidor mediante sockets, desde la perspectiva del servidor. Se utiliza el protocolo HFTP (Homemade File Transfer Protocol) una versiÃ³n "casera" de FTP creado especialmente para este laboratorio el cual funciona en la capa de aplicaciÃ³n. HFTP hace uso de TCP como protocolo de transporte. El servidor HFTP escucha pedidos en el puerto 19500

## Objetivos
* Aplicar la comunicaciÃ³n cliente/servidor por medio de la programaciÃ³n de sockets,
desde la perspectiva del servidor.
* Familiarizarse con un protocolo de aplicaciÃ³n diseÃ±ado en casa.
* Comprender, diseÃ±ar e implementar un programa servidor de archivos en Python.

## Como funciona el paradigma cliente/servidor?
El paradigma cliente-servidor es un modelo de la capa de aplicaciÃ³n en el cual existen proveedores de recursos o servicios, llamados servidores, y los demandantes de estos recursos, llamados clientes. Un cliente realiza peticiones a otro programa, el servidor, quien le da respuesta.

El funcionamiento bÃ¡sico del paradigma cliente-servidor implica los siguientes pasos:

1. *Inicio de la solicitud*: un cliente inicia una solicitud enviando una peticiÃ³n al servidor.

2. *EnvÃ­o de la solicitud al servidor*: usando protocolos, como HTTP para aplicaciones web o TCP/IP para comunicaciones en red, como en nuestro caso.

3. *Procesamiento de la solicitud*: una vez que el servidor recibe la solicitud del cliente, la procesa y determina cÃ³mo debe responder. Esto puede implicar acceder a una base de datos, ejecutar una operaciÃ³n especÃ­fica o recuperar recursos del sistema.

4. *GeneraciÃ³n de una respuesta por parte del servidor*: el servidor genera una respuesta que contiene los resultados solicitados o informaciÃ³n relevante ademÃ¡s de los cÃ³digos acordados para cada situaciÃ³n (como en nuestro caso 0 es OK, 100 bad eol. etc ).

5. *RecepciÃ³n y procesamiento de la respuesta por parte del cliente*: una vez que el cliente recibe la respuesta del servidor, la procesa segÃºn sea necesario, haciendo cosas como, decodificar la informaciÃ³n o mostrarla por pantalla.

Este proceso de solicitud-respuesta puede repetirse varias veces durante la interacciÃ³n entre el cliente y el servidor, hasta que ambos acuerden cerrar la conexiÃ³n.

## Â¿En que se diferencian Stream (TCP) y Datagram (UDP)?
ConexiÃ³n o No conexiÃ³n:
* Stream (TCP): establece una conexiÃ³n antes de transferir datos a travÃ©s del Three-Way Handshake. La conexiÃ³n proporciona garantÃ­as de entrega secuencial, confiable y sin errores.
* Datagram (UDP): no hay establecimiento de conexiÃ³n previo ni handshake. Esto significa que no hay garantÃ­as de entrega secuencial, confiable ni sin errores; los mensajes pueden perderse, duplicarse o llegar en un orden diferente al enviado.
Manejo de los datos:
* Stream (TCP): los datos se transmiten de manera continua y secuencial. Se garantiza que los datos lleguen en el mismo orden en que se enviaron. TCP gestiona automÃ¡ticamente la segmentaciÃ³n de datos en paquetes mÃ¡s pequeÃ±os, su reensamblaje en el orden correcto y la retransmisiÃ³n en caso de pÃ©rdida o corrupciÃ³n.
* Datagram (UDP): Cada mensaje enviado es tratado como una unidad independiente. No hay garantÃ­as de que los mensajes lleguen en el orden correcto, ni de que lleguen en absoluto. UDP no gestiona la segmentaciÃ³n, el ordenamiento ni la retransmisiÃ³n de los datos; estas
responsabilidades deben ser manejadas por la aplicaciÃ³n si son necesarias
Overhead y eficiencia:
* Stream (TCP): tiende a tener un mayor overhead debido a los mecanismos que emplea para tener establecer y mantener una conexiÃ³n segura. Sin embargo, esto tambiÃ©n significa que TCP es mÃ¡s adecuado para aplicaciones que requieren transferencias de datos fiables y en orden.
* Datagram (UDP): tiene menor overhead ya que no emplea los mecanismos de TCP. Es mÃ¡s adecuado para aplicaciones que priorizan la velocidad y pueden tolerar pÃ©rdidas ocasionales de datos, como la transmisiÃ³n de video en tiempo real o juegos en lÃ­nea.

## Â¿QuÃ© es el protocolo FTP?
FTP (File Transfer Protocol) es un protocolo estÃ¡ndar de la capa de aplicaciÃ³n utilizado para la transferencia de archivos entre un cliente y un servidor en una red de computadoras, como Internet. Fue desarrollado originalmente en la dÃ©cada de 1970 y ha sido ampliamente utilizado.

El protocolo FTP permite a los usuarios transferir archivos de una computadora a otra a travÃ©s de una red TCP/IP. Funciona en un modelo cliente-servidor, donde un cliente realiza solicitudes de transferencia de archivos a un servidor FTP donde estÃ¡n alojados.

## Â¿Que es el base64?
Base64 es un sistema de codificaciÃ³n que permite representar datos binarios de manera legible y transferible a travÃ©s de medios que pueden manejar solo texto, como documentos HTML o nuestro HFTP. Funciona convirtiendo datos binarios en una cadena de caracteres ASCII de 64 caracteres, de ahÃ­ su nombre.
Esta codificaciÃ³n nos permite incorporar a nuestro archivo caracteres especiales como lo son el â€˜\r\nâ€™ o que escapen del estÃ¡ndar ascii como lo son las letras con acentos, ademÃ¡s de ayudar a fraccionar los datos para transmitirlos modularmente por la red pudiendolos volver a unir con una asegurada integridad.

## ImplementaciÃ³n
Para lograr nuestro objetivo, trabajamos a partir de un esqueleto otorgado por la cÃ¡tedra, en el cual debÃ­amos modificar los mÃ³dulos 'server.py' y 'connection.py' para realizar la conexiÃ³n y las tareas de recibir, procesar y enviar respuestas al cliente. Esta implementaciÃ³n consiste en una clase Server que toma como argumentos una direcciÃ³n IP, un puerto y un directorio. Por default, estos valores son iguales a las constantes DEFAULT_ADDR, DEFAULT_PORT y DEFAULT_DIR (definidas en 'constants.py') respectivamente. Dentro de esta clase estÃ¡n `__init__()` que es la funciÃ³n constructora que deben tener todas las clases. Luego estÃ¡ la funciÃ³n serve() la cual estÃ¡ escuchando a nuevas conexiones, una vez aceptada crea un hilo (lo que permite que haya mÃºltiples usuarios conectados al servidor simultÃ¡neamente) para esa conexion llamando como target a user_connection(). Esta Ãºltima se encarga de crear las conexiones Ãºnicas para cada cliente a medida que estos se van conectando, esto lo hace creando un objeto de la clase Connection y llamando al mÃ©todo handle para que el servidor comience a responder pedidos del cliente.

En el archivo 'connection.py' esta definida la clase Connection() que toma como argumento un objeto socket y una string que contenga el directorio donde estÃ¡ montado el servidor. Dentro de esta clase esta nuevamente `__init__()` que, ademÃ¡s de inicializar las variables socket y directory a sus respectivos argumentos, inicializa tres variables que son connected (flag que indica si la conexion al cliente sigue), buffer_in y buffer_out que son los buffer que almacenan los datos que entran al servidor y salen del servidor respectivamente.
En este archivo se definen las funciones que van a responder a los comandos get_file_listing, get_metadata, get_slice y quit. Si el comando se realiza con Ã©xito, el servidor devuelve primero un 0 OK\r\n.
### get_file_listing
Este comando no toma argumentos y retorna una lista de los archivos disponibles en el directorio donde estÃ¡ montado el servidor. La funciÃ³n que realizamos para satisfacer ese pedido es:
```python
def get_file_listing(self):
	self.buffer_out = "%s %s %s" % (CODE_OK,
                                	error_messages[CODE_OK],
                                	EOL)
	self.send()
	try:
    	self.buffer_out = '\r\n'.join(os.listdir(self.directory)) +\
                        	"\r\n" + EOL
    	self.send()
	except FileNotFoundError:
    	self.buffer_out = "%s %s %s" % (FILE_NOT_FOUND,
                                    	error_messages[FILE_NOT_FOUND],
                                    	EOL)
    	self.send()
```
```shell
get_file_listing
0 OK
archivo2.txt
archivo1.txt
archivo3.txt
```

### get_metadata FILENAME
Este comando toma el nombre de un archivo como argumento y retorna el tamaÃ±o de ese archivo en bytes. La funciÃ³n que realizamos para este comando es:
```python
def get_metadata(self, filename):
	try:
    	aux = os.stat(self.directory + '/' + filename)
    	self.buffer_out = "%s %s %s" % (CODE_OK,
                                    	error_messages[CODE_OK],
                                    	EOL)
    	self.send()
    	self.buffer_out = "%d" % aux.st_size + EOL
    	self.send()
	except FileNotFoundError:
    	self.buffer_out = "%s %s %s" % (FILE_NOT_FOUND,
                                    	error_messages[FILE_NOT_FOUND],
                                    	EOL)
    	self.send()
```
```shell
get_metadata archivo1.txt
0 OK
46
```

### get_slice FILENAME OFFSET SIZE
Este comando toma el nombre de un archivo y dos valores enteros, y retorna el pedazo del archivo desde la posiciÃ³n OFFSET hasta OFFSET+SIZE. La funciÃ³n que realizamos para este comando es:
```python
def get_slice(self, file, offset, size):
	if offset + size >= os.path.getsize(os.path.join(self.directory,
                                                    	file)):
    	self.buffer_out = "%s %s%s" % (BAD_OFFSET,
                                    	error_messages[BAD_OFFSET],
                                    	EOL)
    	self.send()
	else:
    	toread = open(os.path.join(self.directory, file), "rb")
    	toread.seek(offset)
    	res = toread.read(size)
    	toread.close()
    	self.buffer_out = "%s %s%s" % (CODE_OK, error_messages[CODE_OK],
                                    	EOL)
    	self.send()
    	self.buffer_out = "%s%s" % (b64encode(res).decode("ascii"), EOL)
    	self.send()
```
```shell
get_slice archivo1.txt 5 20
0 OK
Y2Fsb3IgcXVlIGhhY2UgaG95LCA=
```

### quit
Este comando ni toma ni retorna ningÃºn valor, simplemente termina la conexiÃ³n con el servidor. La funciÃ³n implementada para esto es:
```python
def quit(self):
	response = f"{CODE_OK} OK{EOL}"
	self.socket.sendall(response.encode('utf-8'))
	self.connected = False
	self.socket.close()
```
```shell
quit
0 OK
Connection closed by foreign host.
```

Para asegurarnos que el servidor sea robusto y capaz de responder adecuadamente a cada error que suceda, implementamos ciertos chequeos y mecanismos sobre que hacer cuando surjan los siguientes errores. Estos errores y sus cÃ³digos de respuestas son:
* 100: se encontrÃ³ un carÃ¡cter \n fuera de un terminador de pedido \r\n.
* 101: alguna malformaciÃ³n del pedido impidiÃ³ procesarlo.
* 199: el servidor tuvo algÃºn fallo interno al intentar procesar el pedido.
* 200: el comando no estÃ¡ en la lista de comandos aceptados.
* 201: la cantidad de argumentos no corresponde o no tienen la forma correcta.
* 202: el pedido se refiere a un archivo inexistente.
* 203: el pedido se refiere a una posiciÃ³n inexistente en un archivo.

Cada cÃ³digo de error que devuelve el servidor viene acompaÃ±ado con un mensaje de error definido en el diccionario `error_messages` en el archivo `constants.py`.

Luego estÃ¡n las funciones `send()` y `read_line()` que se encargan de mandar datos al cliente y recibir datos del cliente, respectivamente. Finalmente, la funcion `handle()` es la principal funcion que llama el servidor para atender a los pedidos del cliente, y `call_handle()` y `handle_command()` son las principales que reciben los datos del cliente y determinan si es un comando que el servidor puede realizar y si lo es lo ejecuta.

## Errores y dificultades presentadas en el laboratorio
Una las dificultades que se nos presento en este laboratorio fue como manejar el hecho que el cliente mande apriete CTRL + C debido a que esta seÃ±al no puedo ser decodificada por la funciÃ³n `decode('ascii')` y salta un error de *UnicodeDecodeError*. Pudimos solucionar este problema verificando si el mensaje que mando el cliente es igual a la constate *CTRL_C* (definida al final de `constants.py`), si lo es no lo decodificamos a ascii y luego hay un bloque de codigo en `handle()` que se ocupa de terminar la conexion con el servidor. Y si no, se decofica el mensaje en ascii y luego este se trata acorde a lo que contenga el mensaje.
Otra dificultad fue hacer que el servidor sea los mas resistente a errores o a hechos no comunes que puedan romper el funcionamiento del mismo. Por suerte contÃ¡bamos con los tests unitarios que podrÃ­an guiarnos para encontrar y solucionar los casos "no felices".

## ConclusiÃ³n
### En conclusiÃ³n, en este laboratorio logramos:
* Construir un servidor que utilice HFTP (Home-made File Transfer Protocol) y establecer una comunicaciÃ³n cliente/servidor mediante sockets.
* Que el servidor reciba y responda adecuadamente a los comandos que manda el cliente.
* Que el servidor sea capaz de manejar errores que puedan ocurrir.
* Que el servidor sea capaz de manejar mÃºltiples clientes mediante hilos

AdemÃ¡s pudimos notar cierta relaciÃ³n entre este laboratorio y el anterior. Mientras que las APIs, como la desarrollada en el lab01, proporcionan un conjunto de funciones y protocolos para interactuar con un sistema o servicio, los sockets son utilizados para establecer y manejar conexiones de red entre diferentes programas o dispositivos, permitiendo la transferencia de datos a travÃ©s de esa conexiÃ³n. De hecho, las APIs se respaldan en los sockets para facilitar la comunicaciÃ³n entre el software y otros sistemas o servicios remotos. Cabe aclarar que ambos servicios corren en la capa de aplicaciÃ³n

## Preguntas
1. Â¿QuÃ© estrategias existen para poder implementar este mismo servidor pero con capacidad de atender mÃºltiples clientes simultÃ¡neamente?
 Existen distintas estrategias para que este servidor pueda atender mÃºltiples clientes simultÃ¡neamente, entre ellas, multi-threading (ya implementada), forking, poll, etc. En multi-threading cada cliente es manejado por un hilo distinto. En cambio, forking el servidor crea un nuevo proceso para cada nuevo cliente entonces en el cÃ³digo deberÃ­a reemplazar la creaciÃ³n de un hilo en `serve()` por la creaciÃ³n de un proceso. Sin embargo, esta Ãºltima estrategia puede exigir muchos recursos al servidor si se conectan muchos clientes. Finalmente, en poll el servidor se fija periÃ³dicamente si llegaron datos del cliente en vez de esperar a que lleguen. Para esta estrategia se podrÃ­a utilizar el mÃ©todo `select()` o `poll()`. La diferencia entre estos radica en que `select()` requiere que la aplicaciÃ³n pase un array de bits donde un bit es usado para representar cada un file descriptor (en este caso, del socket) pero este tiene un lÃ­mite, indicado en el macro *FD_SETSIZE*, de cuantos file descriptors puede monitorear. En cambio, `poll()` toma un array de structs (pollfd) propios de cada file descriptor, donde cada uno ocupa hasta 8 bytes, entonces pueden haber file descriptors con nÃºmeros mÃ¡s grandes.
 2. `localhost` es un hostname que se refiere a la computadora, normalmente se traduce a la direcciÃ³n 127.0.0.1. Entonces, estas dos direcciones refieren a lo mismo. Sin embargo, la direcciÃ³n `0.0.0.0` es para representar todas las direcciones IPv4 en la mÃ¡quina o asociados a esta entonces puede aceptar conexiones de IPs externas a la red. Entonces, usar como direcciÃ³n a 127.0.0.1 y localhost no hay diferencia en el funcionamiento del servidor. Sin embargo, usar 0.0.0.0 como direccion abre la posibilidad de que computadoras distintas a la del servidor (de las misma red o externa) pueda conectarse y eso expone al servidor a algÃºn agente malicioso o negligente que pueda ocasionar problemas en el servidor, sobre todo en uno donde no se contemplÃ³ mucho la seguridad durante el diseÃ±o e implementaciÃ³n del mismo.
 Abajo hay un ejemplo de cÃ³mo puede acceder una mÃ¡quina de la misma red:
#### Servidor
```shell
nacho@ubuntu:~$ ifconfig
wlp2s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
    	inet 192.168.0.111  netmask 255.255.255.0  broadcast 192.168.0.255
    	inet6 fe80::168f:b84d:3dc7:c9ba  prefixlen 64  scopeid 0x20<link>
    	ether 40:5b:d8:01:17:f5  txqueuelen 1000  (Ethernet)
    	RX packets 57167  bytes 49277763 (49.2 MB)
    	RX errors 0  dropped 2  overruns 0  frame 0
    	TX packets 37638  bytes 10647217 (10.6 MB)
    	TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

(.venv) nacho@dell:~/Documents/famaf/redes/labs/redes24lab2g13$ python server.py -d servidor/
Serving servidor/ on 0.0.0.0:19500.
Connected by: ('192.168.0.109', 54297)
servidor/
get_file_listing

COMANDO: get_file_listing
```
```shell
(.venv) nacho@dell:~/Documents/famaf/redes/labs/redes24lab2g13$ ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
	inet 192.168.153.128  netmask 255.255.255.0  broadcast 192.168.153.255
	inet6 fe80::495b:5b7e:9dfe:5e91  prefixlen 64  scopeid 0x20<link>
	ether 00:0c:29:d6:d9:f2  txqueuelen 1000  (Ethernet)
	RX packets 5110  bytes 7149466 (7.1 MB)
	RX errors 0  dropped 0  overruns 0  frame 0
	TX packets 1740  bytes 166542 (166.5 KB)
	TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```
#### Cliente
```shell
nacho@ubuntu:~$ telnet 192.168.0.111 19500
Trying 192.168.0.111...
Connected to 192.168.0.111.
Escape character is '^]'.
get_file_listing
0 OK
archivo2.txt
archivo1.txt
archivo3.txt

quit
0 OK
Connection closed by foreign host.
```